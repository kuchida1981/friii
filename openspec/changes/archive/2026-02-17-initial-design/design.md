## Context

フリーランスエンジニア向けの「優良な電子帳簿」要件を満たす会計システムの初期設計です。Go (Backend) と React (Frontend) を使用し、Docker Compose でローカル開発環境を構築します。GraphQL を介した通信を行い、PostgreSQL で不変性を重視したデータ管理を行います。

## Goals / Non-Goals

**Goals:**
- 「優良な電子帳簿」要件（不変性、履歴保持、検索性）を物理レベルおよび論理レベルで担保するアーキテクチャの定義
- フリーランスエンジニアに特化した最小限かつ拡張可能なデータモデルの構築
- Docker Compose によるワンコマンドでの開発環境立ち上げの実現
- GraphQL (gqlgen) を用いた型安全な API インターフェースの提供

**Non-Goals:**
- 銀行APIやクレジットカード連携の実装（今回は手入力に特化）
- e-Tax への直接的なデータ送信機能（出力された BS/PL を元にユーザーが手入力することを想定）
- 法人会計への対応（個人事業主専用とする）

## Decisions

### 1. アーキテクチャ: Clean Architecture の採用
Go バックエンドでは Clean Architecture を採用し、ドメインロジック（簿記ルール）をインフラストラクチャやフレームワークから分離します。
- **Rationale**: 会計ルールは変更が少ない一方で、フロントエンドの技術やデータベースの詳細は将来的に変更される可能性があるため。

### 2. データ保存: PostgreSQL + Immutable Journaling
仕訳データは `UPDATE` や `DELETE` を行わず、`INSERT` のみで管理します。
- **Rationale**: 「訂正・削除履歴の確保」要件をデータベースレベルで強制するため。修正は「赤黒処理」による新規レコード追加として実装します。

### 3. API: GraphQL (gqlgen)
バックエンドとフロントエンドの通信には GraphQL を使用します。
- **Rationale**: 会計データは階層構造（仕訳 -> 仕訳行 -> 勘定科目）を持つため、GraphQL のグラフ構造との親和性が高いため。また、フロントエンド（React）が必要なデータのみを柔軟に取得できるため。

### 4. 取引先管理の統合
仕訳行 (`journal_entries`) に取引先ID (`client_id`) を保持できるようにします。
- **Rationale**: 決算時に取引先ごとの売上集計が必要になるため。

## Risks / Trade-offs

- **[Risk] データ量の増大** → [Mitigation] 仕訳の不変性を保つためデータ量は増えるが、個人事業主の年間仕訳数は数千件程度であり、PostgreSQL の性能範囲内で十分に対応可能。
- **[Risk] 赤黒処理の複雑性** → [Mitigation] ドメイン層に厳密なバリデーションと修正ロジックを実装し、テストコードで挙動を保証する。
